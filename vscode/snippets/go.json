{
	// Place your snippets for go here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Test function": {
		"prefix": "testFunc",
		"body": [
			"func Test$1(t *testing.T){",
			"testCases := []struct {",
			"    name           string",
			"    expectedResult bool",
			"    $2",
			"}{",
			"    {",
			"        name:           \"test $1\",",
			"        expectedResult: true,",
			"    },",
			"}",
			"for _, tc := range testCases {",
			"    t.Run(tc.name, func(t *testing.T) {",
			"        $0",
			"    })",
			"}",
			"}"
		],
		"description": "Test function"
	},

	"Table driven test": {
		"prefix": "testTableDrivenBody",
		"body": [
			"testCases := []struct {",
			"    name           string",
			"    expectedResult bool",
			"    $2",
			"}{",
			"    {",
			"        name:           \"test $1\",",
			"        expectedResult: true,",
			"    },",
			"}",
			"for _, tc := range testCases {",
			"    t.Run(tc.name, func(t *testing.T) {",
			"        $0",
			"    })",
			"}",
		],
		"description": "Table driven test body"
	},

	"Terraform acceptance test": {
	"description": "",
	"prefix": "tfacc",
	"body": [
		"var terraformResourceType${1} string = \"\"",
		"",
		"func Test$1_basic(t *testing.T) {",
		"",
		"resourceName := \"resource.testacc\"",
		"",
		"resource.Test(t, resource.TestCase{",
		"    PreCheck:          func() { testAccPreCheck(t) },",
		"    ProviderFactories: testAccProviderFactories,",
		"    CheckDestroy:      testAccCheck$1Destroy,",
		"    Steps: []resource.TestStep{",
		"        {",
		"            Config: testAcc${1}Config(),",
		"            Check: resource.ComposeAggregateTestCheckFunc(",
		"                testAcc$1Exists(resourceName),",
		"                resource.TestCheckResourceAttrSet(resourceName, \"id\"),",
		"            ),",
		"        },",
		"    },",
		"})",
		"}",
		"",
		"func testAcc$1Exists(resourceID string, record *${1}) resource.TestCheckFunc {",
		"    return func(s *terraform.State) error {",
		"        r, ok := s.RootModule().Resources[resourceID]",
		"        if !ok {",
		"            return fmt.Errorf(\"resource %q not found in state\", resourceID)",
		"        }",
		"        if r.Primary.ID == \"\" {",
		"            return fmt.Errorf(\"resource %q has empty primary ID in state\", resourceID)",
		"        }",
		"        c := NewClient()",
		"        remoteRecord, err := c.Find${1}(r.Primary.ID)",
		"        if err != nil {",
		"            return err",
		"        }",
		"        *record = *remoteRecord",
		"",
		"return nil",
		"    }",
		"}",
		"",
		"func testAccCheck${1}Destroy(s *terraform.State) error {",
		"    c := client.NewClient(client.GetConfigFromEnv())",
		"    for _, rs := range s.RootModule().Resources {",
		"        if rs.Type != terraformResourceType${1} {",
		"            continue",
		"        }",
		"",
		"        remoteRecord, err := c.Find${1}(rs.Primary.ID)",
		"        _, ok := err.(*client.NotFound)",
		"        if err != nil && !ok {",
		"            return fmt.Errorf(\"expected not found error, got %+#v\", err)",
		"        }",
		"",
		"        if remoteRecord != nil {",
		"            return fmt.Errorf(\"resource %T with id %q still exists in remote system\", remoteRecord, remoteRecord.Id)",
		"        }",
		"    }",
		"",
		"    return nil",
		"}",
		"",
		"func testAcc${1}Config() string {",
		"    return fmt.Sprintf(`",
		"        resource \"$1\" \"testacc\" {",
		"        }",
		"    `)",
		"}"
	]
	},
	"Terraform resource": {
		"description": "Terraform resource template",
		"prefix": "tfresource",
		"body": [
			"func resource${1}() *schema.Resource {",
			"    return &schema.Resource{",
			"        Description: \"New resource\",",
			"",
			"        CreateContext: resource${1}Create,",
			"        ReadContext:   resource${1}Read,",
			"        UpdateContext: resource${1}Update,",
			"        DeleteContext: resource${1}Delete,",
			"",
			"        Importer: &schema.ResourceImporter{",
			"            StateContext: schema.ImportStatePassthroughContext,",
			"        },",
			"",
			"        Schema: map[string]*schema.Schema{",
			"            \"id\": {",
			"                Type:     schema.TypeString,",
			"                Computed: true,",
			"            },",
			"        },",
			"    }",
			"}",
			"",
			"func resource${1}Create(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {",
			"    // d.SetId(r.id)",
			"",
			"    return resource${1}Read(ctx, d, m)",
			"}",
			"",
			"func resource${1}Read(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {",
			"    var diags diag.Diagnostics",
			"",
			"    return diags",
			"}",
			"",
			"func resource${1}Update(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {",
			"    var diags diag.Diagnostics",
			"",
			"    return diags",
			"}",
			"",
			"func resource${1}Delete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {",
			"    var diags diag.Diagnostics",
			"",
			"    return diags",
			"}",
			"",
			"func dataTo${1}(d *schema.ResourceData) *${1} {",
			"    return &${1}{",
			"        Id: d.Id(),",
			"        // Field: d.Get(\"field\").(string),",
			"    }",
			"}",
			"",
			"func record${1}ToData(r *${1}, d *schema.ResourceData) diag.Diagnostics {",
            "    var diags diag.Diagnostics",
			"",
            "    if err := d.Set(\"field\", r.Field); err != nil {",
            "        diags = append(diags, diag.FromErr(err)...)",
            "    }",
			"",
			"    d.SetId(r.Id)",
            "",
            "    return diags",
			"}"
		]
	}
}
